## 자료구조 & 알고리즘

<details>
<summary>📚 공부한 자료</summary>

- 파이썬 알고리즘 인터뷰

</details>

### **1. 시간복잡도와 공간복잡도에 대해 설명해 주세요.**
- 시간복잡도: 알고리즘이 실행되는 데에 걸리는 시간을 입력 크기에 따라 표현한 것.
  - 예) 배열 정렬 알고리즘의 시간복잡도는 O(N log N)
- 공간복잡도: 알고리즘이 사용하는 메모리 공간을 입력 크기에 따라 표현한 것.
  - 예) 재귀 호출은 추가적인 스택 메모리를 사용하므로 공간복잡도가 더 높다.

- **Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.**
  - Big-O: 알고리즘의 최악의 시간/공간 복잡도를 나타낸다.
    - 예) O(N) 은 최대 N 만큼의 시간이 걸린다.
  - Big-Theta(Θ): 알고리즘의 평균적인 시간/공간 복잡도를 나타낸다.
    - 예) Θ(N) 은 평균적으로 N 만큼의 시간이 걸린다.
  - Big-Omega(Ω): 알고리즘의 최선의 시간/공간 복잡도를 나타낸다.
    - 예) Ω(1) 은 최소 상수 시간으로 실행될 수 있다.
- **다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?**
  - Big-O 는 최악의 경우를 표현하는데, 최악의 경우를 고려해야 안정성이 보장되며
    알고리즘이 최악의 상황에서 얼마나 효율적인지를 보장할 수 있기 때문이다.
  - 가장 널리 사용되기 때문에 알고리즘 성능 비교에 표준화된 척도를 제공한다.
- **O(1)은 O(N^2) 보다 무조건적으로 빠른가요?**
  - 입력 크기가 큰 경우에서는 O(1) 이 O(N^2) 보다 효율적인 것은 맞지만, 절대적으로 빠르다고 단정할 수는 없다.
  - 입력 크기가 작은 경우에는 O(1) 이 더 느린 경우도 있고, 알고리즘의 실제 실행 속도는 하드웨어, 구현 세부 사항, 상수 시간 연산 등에 영향을 받는다.

### **2. 링크드 리스트에 대해 설명해 주세요.**
A. 링크드 리스트(Linked List) 란 `노드(node)` 라 불리는 개별 요소들이 포인터를 통해 연결된 자료구조이다.
- 단일 연결 리스트(Singly Linked List): 한 방향으로만 연결
- 이중 연결 리스트(Doubly Linked List): 양방향으로 연결
- 원형 연결 리스트(Circular Linked List): 마지막 노드가 처음 노드와 연결

- **일반 배열과, 링크드 리스트를 비교해 주세요.**
  - 메모리 구조: 배열은 연속된 메모리에 저장되지만, 링크드 리스트는 비연속적인 메모리에 노드들이 포인터로 연결된다.
  - 접근 속도: 배열은 인덱스를 통해 O(1)로 임의 접근이 가능하지만, 링크드 리스트는 순차 탐색이 필요해 O(N) 이다.
  - 삽입/삭제: 배열은 특정 위치에서 데이터 이동이 필요해 O(N)이며, 링크드 리스트는 참조값 변경으로 O(1) 이다.
  - 크기 조정: 배열은 크기가 고정되어 재할당이 필요하지만, 링크드 리스트는 동적으로 크기 조정이 가능하다.
  - 메모리 사용량: 배열은 데이터만 저장해 메모리를 적게 사용하지만, 링크드 리스트는 데이터와 포인터를 저장해 더 많은 메모리를 사용한다.

- **링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.**
  1. 스택(Stack): LIFO(Last In, First Out) 구조이며, `단일 연결 리스트` 를 사용해 push 와 pop 을 구현한다.
  2. 큐(Queue):  FIFO(First In, First Out) 구조이며, `단일 연결 리스트` 를 사용해 앞쪽에서 데이터를 제거하고 뒤쪽에서 데이터를 추가한다.
  3. 덱(Deque): 양쪽 끝에서 삽입과 삭제가 가능한 구조이며, `이중 연결 리스트` 를 사용해 양방향 접근이 가능하다.

### **3. 스택과 큐에 대해서 설명해 주세요.**
- 스택(Stack): LIFO(Last In, First Out) 구조로, 가장 마지막에 추가된 데이터가 가장 먼저 제거된다.
  - 주요 연산
    - push: 데이터를 스택에 추가
    - pop: 가장 위의 데이터를 제거하면서 반환
    - peek: 가장 위의 데이터를 확인
- 큐(Queue): FIFO(First In, First Out) 구조로, 가장 먼저 추가된 데이터가 가장 먼저 제거된다.
  - 주요 연산
    - enqueue: 데이터를 큐에 추가
    - dequeue: 가장 앞의 데이터를 제거하고 반환
    - peek: 가장 앞의 데이터를 확인

- **스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.**
  A. 스택 2개로 큐
  - enqueue 연산: 스택 A에 데이터를 추가하고, 스택 B를 사용해 데이터를 반전한다.
    - 시간 복잡도: O(1)
  - dequeue 연산: 스택 B가 비어 있으면, 스택 A에서 모든 데이터를 팝하며 스택 B로 push 한다.
    - 시간 복잡도: O(N)
  A. 큐 2개로 스택
  - 큐 A를 기본 큐로 사용하고, 큐 B를 임시 큐로 사용한다.
  - push 연산: 새 데이터를 큐 B에 추가하고, 큐 A의 모든 데이터를 큐 B로 옮긴 뒤, 큐 B와 A의 역할을 교체한다.
    - 시간 복잡도: O(N)
  - pop 연산: 큐 A의 데이터를 제거하고 반환
    - 시간 복잡도: O(1)

- **시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?**
  - 배열로 스택 구현: 배열의 끝을 스택의 top 으로 간주하여 push 와 pop 연산을 수행한다. (모두 복잡도는 O(1)) 
  - 배열로 큐 구현: 배열의 앞과 뒤를 큐의 front 와 rear 로 간주한다. (모두 복잡도는 O(1))  

  - **Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.**
    - Infix: 연산자가 피연산자 사이에 위치 (예: A + B).
    - Prefix: 연산자가 피연산자 앞에 위치 (예: + A B).
    - Postfix: 연산자가 피연산자 뒤에 위치 (예: A B +).
      - Postfix 계산 (스택 활용)
        1. 문자열을 왼쪽부터 차례로 읽는다.
        2. 피연산자는 스택에 push
        3. 연산자가 나오면 스택에서 두 개의 값을 pop 하고 연산 후 결과를 다시 push.
        4. 문자열 끝까지 반복하면 최종 결과가 스택에 남는다.
        ```java
        // 예시: 2 3 + 4 *
        Step 1: 2 → push, 3 → push, + → pop 2, 3 → 5 → push.
        Step 2: 4 → push, * → pop 5, 4 → 20 → push.
        결과: 20.
        ```

- **Deque는 어떻게 구현할 수 있을까요?**
  - Deque(양방향 큐)는 이중 연결 리스트 또는 배열로 구현할 수 있다.
  - 이중 연결 리스트
    - 양방향 노드 구조를 사용하여 삽입/삭제 연산을 효율적으로 처리.
    - 각각의 노드가 이전 노드와 다음 노드의 참조를 가짐.
  - 배열
    - head와 tail 포인터를 사용해 양쪽 끝에서 삽입/삭제 연산을 수행.
    - 원형 배열을 활용하면 효율적으로 메모리 사용 가능.
 
- **(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?**
A. C++ 의 dequeue 는 분할된 메모리 블록으로 구현되는데, 메모리 블록의 주소를 인덱스 배열로 관리하므로 특정 인덱스에 빠르게 접근할 수 있다.
인덱스 배열을 통해 원하는 블록에 접근하고, 블록 내에서 다시 데이터를 참조하므로 O(1) 시간복잡도를 유지한다.

### **4. 해시 자료구조에 대해 설명해 주세요.**
A. 해시 자료구조는 Key-Value 쌍을 저장하는 자료구조로, 해시 함수를 사용해 데이터를 고유한 인덱스(=해시값)로 변환하고
해당 인덱스에 데이터를 저장하는 방식이다. 평균적으로 O(1) 의 시간 복잡도를 가진다.

- **값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?**
  - 충돌을 줄이는 좋은 해시 함수의 조건:
    1. 입력 균등 분포: 입력 값이 해시 테이블의 모든 버킷에 고르게 분포.
    2. 결정론적: 같은 입력에 항상 동일한 해시값 반환.
    3. 빠른 계산: 해시값 계산이 효율적이어야 함.
    4. 입력 민감성: 입력이 조금만 바뀌어도 해시값이 크게 변경되어야 함.

- **해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?**
  - 서로 다른 키가 동일한 해시값을 가질 때 해시 충돌이 발생하게 된다.
  - 대표적인 해결 방식:
    1. 체이닝(Chaining): 동일한 해시값을 가지는 데이터들을 연결 리스트로 관리한다.
    2. 개방 주소법(Open Addressing): 충돌 발생 시, 빈 버킷을 찾아 데이터를 저장한다.
    - ex) 선형 탐색, 이차 탐색, 이중 해싱
    3. 성능 최적화 - 트리화(Treeification): 연결 리스트의 노드 수가 8개 이상이면 Red-Black Tree 로 전환한다. 8개 미만일 경우 연결 리스트로 유지한다.

- **본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?**
A. Java 에서는 `HashMap` 과 `Hashtable` 이 대표적인 해시 기반 자료구조이며,
체이닝과 트리화 방식으로 해시 충돌을 처리한다.
- 기본 방식: 체이닝 (Chaining).
- 최적화 방식: 트리화 (Red-Black Tree) (Java 8부터 도입).
- 키 비교: equals()와 hashCode() 메서드를 통해 동일 키 여부 판별.
- 성능: 연결 리스트 사용 시: O(n), 트리화 적용 시: O(log n)

- **Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.**
A. Double Hashing(이중 해싱) 은 두 개의 해시 함수를 사용하여 충돌을 해결하는 개방 주소법의 한 방식이다.
  - 장점
    - 충돌 시 탐색 간격이 고정되지 않고 다양화되어 클러스터링 문제 감소.
    - 탐색 성능 향상.
  - 단점
    - 복잡성 증가: 두 개의 해시 함수를 계산해야 하므로 성능 저하 가능.
    - 테이블 크기가 소수여야만 효과적.
  - 해결책: 적절한 해시 함수 설계 및 테이블 크기를 소수로 설정하거나, 로드 팩터(해시 테이블이 얼마나 채워졌는지를 나타내는 지표) 조정을 통해 성능을 유지한다.

- **Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?**
A. Load Factor(로드 팩터)란 해시 테이블이 얼마나 채워졌는지를 나타내는 지표이다.
Java 의 `HashMap` 에서는 초기 크기가 16(2^4), 로드 팩터가 기본값 0.75 로 설정되어 있다.

- **다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.**
A. Race Condition 은 여러 스레드가 동시에 해시 테이블을 수정할 때 데이터 충돌이 발생하는 현상이다.
- 해결 방법 설계 (성능 감소 최소화)
1. Concurrent HashMap 사용 (Java 기준)
  - 세그먼트 잠금 (Segment Locking) 사용.
  - 특정 버킷만 잠가 성능을 최적화.
2. Read-Write Lock 사용
  - 읽기 연산은 동시 수행 가능,
  - 쓰기 연산만 단일 잠금.
3. Copy-On-Write 방식 (COW)
  - 데이터 수정 시 새로운 해시 테이블을 복사하여 적용.
  - 쓰기 성능이 떨어지지만, 읽기 성능은 매우 뛰어남.
4. Atomic Variables 사용
  - `AtomicInteger`와 같은 원자 변수 사용.
  - 주로 카운팅 연산에 사용.

### **5. 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.**

- **그래프와 트리의 차이가 무엇인가요?**
- **이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?**
- **이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.**
- **이진탐색트리의 한계점에 대해 설명해주세요.**
- **이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?**
- **이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.**

### **6. 힙에 대해 설명해 주세요.**

- **힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?**
- **힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.**
- **힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?**

### **7. BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.**

- **Red Black Tree는 어떻게 균형을 유지할 수 있을까요?**
- **Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.**
- **2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?**

### **8. 정렬 알고리즘에 대해 설명해 주세요.**

- **Quick Sort와 Merge Sort를 비교해 주세요.**
- **Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.**
- **Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.**
- **Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?**
- **Radix Sort에 대해 설명해 주세요.**
- **Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.**
- **값이 거의 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?**
- **본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?**
- **정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?**

### **9. 그래프 자료구조에 대해 설명하고, 이를 구현할 수 있는 두 방법에 대해 설명해 주세요.**

- **각 방법에 대해, "두 정점이 연결되었는지" 확인하는 시간복잡도와 "한 정점에 연결된 모든 정점을 찾는" 시간복잡도, 그리고 공간복잡도를 비교해 주세요.**
- **정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 방식으로 구현하는 것이 효율적일까요?**
- **사이클이 없는 그래프는 모두 트리인가요? 그렇지 않다면, 예시를 들어주세요.**

### **10. 그래프에서, 최단거리를 구하는 방법에 대해 설명해 주세요.**

- **트리에서는 어떤 방식으로 최단거리를 구할 수 있을까요? (위 방법을 사용하지 않고)**
- **다익스트라 알고리즘에서, 힙을 사용하지 않고 구현한다면 시간복잡도가 어떻게 변화할까요?**
- **정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 알고리즘이 효율적일까요?**
- **A\* 알고리즘에 대해 설명해 주세요. 이 알고리즘은 다익스트라와 비교해서 어떤 성능을 낼까요?**
- **음수 간선이 있을 때와, 음수 사이클이 있을 때 각각 어떤 최단거리 알고리즘을 사용해야 하는지 설명해 주세요.**

### **11. 재귀함수에 대해 설명해 주세요.**
A. 재귀함수란 자기 자신을 호출하는 함수를 말한다.
기본 구성 요소로는 재귀 호출을 멈추는 종료 조건인 `기본 조건`, 자신을 다시 호출하는 `재귀 호출` 이 있다.
```java
public class Factorial {
    public static int factorial(int n) {
        if (n == 1) return 1; // 기본 조건
        return n * factorial(n - 1); // 재귀 호출
    }

    public static void main(String[] args) {
        System.out.println(factorial(5)); // 출력: 120
    }
}
```

- **재귀 함수의 동작 과정을 Call Stack을 활용해서 설명해 주세요.**
  - `Call Stack` 은 함수 호출 정보를 저장하는 스택 메모리 구조이다.
    재귀 함수가 호출될 때마다 새로운 스택 프레임이 생성되고, 종료 조건을 만나면 스택이 순차적으로 해제된다.
  ```
    factorial(3)
  → factorial(2)
  → factorial(1) → 1 (기본 조건 충족, 반환)
  → 2 * 1 → 2 반환
  → 3 * 2 → 6 반환
  ```
  ```
  Call Stack (Top to Bottom)
  ----------------------
  factorial(1) → 반환 1
  factorial(2) → 반환 2
  factorial(3) → 반환 6
  ```
  - 새로운 함수 호출 시 스택 프레임이 추가되며, 기본 조건을 만나면 스택이 역순으로 해제된다.
  
- **언어의 스펙에 따라, 재귀함수의 최적화를 진행해주는 경우가 있습니다. 어떤 경우에 재귀함수의 최적화가 가능하며, 이를 어떻게 최적화 할 수 있을지 설명해 주세요.**
  - 재귀 함수의 최적화는 재귀 호출이 마지막 연산이고, 호출 후 추가 연산이 없을 때 가능하다.
  - Python, C++, Scala 등 일부 언어에서 지원하며, 최적화를 진행하는 경우 스택 프레임을 추가로 생성하지 않고 기존 스택을 재사용해 반복문처럼 사용할 수 있다.

### **12. MST가 무엇이고, 어떻게 구할 수 있을지 설명해 주세요.**

- **Kruskal 알고리즘에서 사용하는 Union-Find 자료구조에 대해 설명해 주세요.**
- **Kruskal 과 Prim 중, 어떤 것이 더 빠를까요?**
- **Kruskal 과 Prim 알고리즘을 통해 얻어진 결과물은 무조건 트리인가요? 만약 그렇다면 증명해 주세요. 그렇지 않다면, 반례를 설명해 주세요.**

### **13. Thread Safe 한 자료구조가 있을까요? 없다면, 어떻게 Thread Safe 하게 구성할 수 있을까요?**

- **배열의 길이를 알고 있다면, 조금 더 빠른 Thread Safe 한 연산을 만들 순 없을까요?**
- **사용하고 있는 언어의 자료구조는 Thread Safe 한가요? 그렇지 않다면, Thread Safe 한 Wrapped Data Structure 를 제공하고 있나요?**

### **14. 문자열을 저장하고, 처리하는 주요 자료구조 및 알고리즘 (Trie, KMP, Rabin Karp 등) 에 대해 설명해 주세요.**

### **15. 이진탐색이 무엇인지 설명하고, 시간복잡도를 증명해 보세요.**

- **Lower Bound, Upper Bound 는 무엇이고, 이를 어떻게 구현할 수 있을까요?**
- **이진탐색의 논리를 적용하여 삼진탐색을 작성한다고 가정한다면, 시간복잡도는 어떻게 변화할까요? (실제 존재하는 삼진탐색 알고리즘은 무시하세요!)**
- **기존 이진탐색 로직에서 부등호의 범위가 바뀐다면, (ex. <= 라면 <로, <이라면 <= 로) 결과가 달라질까요?**

### **16. 그리디 알고리즘과 동적 계획법을 비교해 주세요.**
- 그리디 알고리즘: 매 단계에서 최적 선택, 빠르고 간결하지만 항상 최적해를 보장하지는 않음.
- 동적 계획법: 하위 문제를 해결하고 저장, 더 복잡하지만 최적해를 보장함.

- **그렇다면, 어떤 경우에 각각의 기법을 사용할 수 있을까요?**
  - 그리디 알고리즘: 각 단계에서의 지역 최적해가 전체 문제의 최적해를 보장하는 경우
  - 동적 계획법: 문제를 작은 문제로 나누고, 그 결과를 결합하여 최적해를 구할 수 있는 경우나 동일한 부분 문제가 여러 번 반복되는 경우
  
- **그렇다면, 동적 계획법으로 풀 수 있는 모든 문제는 재귀로 변환하여 풀 수 있나요?**
  - 동적 계획법은 본질적으로 재귀적 구조를 기반으로 문제를 작은 하위 문제로 나누고, 이미 계산된 값을 재사용하는 메모이제이션 방식을 활용한다.
    따라서 동적 계획법으로 풀 수 있는 모든 문제는 재귀로 변환하여 풀 수 있다.
  - 다만 중복되는 하위 문제가 존재하지 않거나 최적 부분 구조를 만족하지 않는 경우에는 동적 계획법이 아닌 다른 접근 방법을 사용하는 것이 더 효율적일 수 있다.