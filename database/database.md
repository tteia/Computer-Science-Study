### **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**
A. 데이터베이스에서 Key 란 데이터의 식별자 역할을 하는 것을 의미한다.
- 기본키(Primary Key) : 고유하게 식별하는 데 사용되는 후보키 중 하나. null 값을 허용하지 않는다.
- 후보키(Candidate Key) : 기본키가 될 수 있는 키들을 의미한다. 유일성과 최소성을 만족해야 한다.
- 슈퍼키(Super Key) : 유일성을 만족하는 키.
- 외래키(Foreign Key) : 다른 테이블의 기본키를 참조하는 키. null 값을 허용하지 않는다.
- 대체키(Alternate Key) : 기본키가 아닌 나머지 후보키를 의미한다.

- **기본키는 수정이 가능한가요?**
  - 기본키는 수정이 가능하나, 수정 전 참조 무결성, 프로그램 영향, 성능 문제 등을 충분히 고려해야 한다.

- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
  - MySQL 의 경우 테이블마다 하나의 기본키를 필수적으로 가져야한다. 만약 기본키를 정의하지 않았다면 NOT NULL 옵션의 UNIQUE 인덱스 중 첫 번째 인덱스를 기본키로 자동 정의한다.
  - 만약 적절한 UNIQUE 인덱스 값마저 없다면, 보이지않는 기본키를 자동 생성한다.
    - 이렇게 자동으로 추가되는 경우, 기본키는 사용자에게 노출되지 않아 쿼리 문장에서 명시적으로 사용할 수 없다.

- **외래키 값은 NULL이 들어올 수 있나요?**
  - 외래키에서는 NULL 값이 허용된다. 두 테이블 간의 관계가 항상 필수적이지 않거나 한 테이블의 데이터가 입력되지 않은 상황에서 레코드를 생성할 경우 NULL 값을 허용할 수 있다.

- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**
  - UNIQUE 가 붙은 컬럼은 자동으로 인덱싱이 되기 때문에 WHERE 절에 사용하는 쿼리인 경우 더 빠르게 데이터를 검색할 수 있다.
  - 하지만 데이터를 삽입, 수정, 삭제할 때는 인덱스가 추가적인 스토리지 공간을 사용하기 때문에 오버헤드가 발생할 수 있다.

### **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**
A.
RDB(Relational Database): 관계형 데이터 모델에 기초를 둔 데이터 베이스.
NoSQL: 관계형 데이터 베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태. 비관계형 데이터 베이스.
- RDB 는 데이터를 행과 열로 이루어진 테이블로 구성하는 반면, NoSQL 은 데이터를 다양한 형태로 구성한다.
- RDB 는 데이터 간의 관계를 명확하게 정의하는 반면, NoSQL 은 관계를 명시하지 않는다.
- RDB 는 ACID 속성을 지원하여 데이터 무결성을 보장하는 반면, NoSQL 은 BASE 특성을 가져 가용성과 성능을 중시한다.
  - ACID
    - Atomic: 하나의 트랜잭션은 성공 | 실패 두 가지 중 하나의 상태만 가져야 한다.
    - Consistency: 트랜잭션의 시작 전 후 상태는 일관되어야 한다.
    - Isolation: 하나의 트랜잭션이 다른 트랜잭션에 간섭하지 않고 독립된 상태에서 진행되어야 한다.
    - Durability: 트랜잭션이 일어났다면 그 결과는 지속되어야 한다.
  - BASE
    - Basically Available: 시스템이 항상 사용, 접근 가능해야 한다.
    - Soft state : 외부의 개입 없이도 상태(정보)가 바뀔 수 있음을 의미한다. 데이터의 일시적인 불일치를 허용하는 것.
    - Eventually Consistent: 일정 시간 경과 시 데이터의 일관성이 유지된다. => 완벽한 일관성을 보장하지는 않는다. 

- **NoSQL의 강점과, 약점이 무엇인가요?**
  - 강점
    - 데이터 간의 관계를 정의하지 않기에 수평 확장, 분산 처리에 용이하다.
    - 쓰기, 읽기 작업이 Non-Blocking 이므로 성능이 좋다.
    - 스키마가 없어 데이터의 수정, 추가가 쉽다.
    - 데이터를 애플리케이션이 필요로 하는 형식으로 저장하기에 데이터를 읽어오는 속도가 빠르다.
  - 단점
    - 데이터 일관성이 깨질 수 있다.
    - 참조 무결성이 깨질 수 있다.
    - 데이터가 중복되어 있는 경우, 수정 작업 시 모든 데이터를 수정해야 한다.
    
- **RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)**
  - 수평 확장이 어렵고, 여러 테이블 간의 데이터를 결합하는 조인 연산이 큰 오버헤드가 될 수 있다.
  - 데이터 일관성을 강하게 보장하기 때문에 트랜잭션과 ACID 속성으로 인한 처리 시간이 길고, 성능 저하를 일으킬 수 있다.

- **NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.**
  - 활용한 적은 없지만, 사용자 데이터 및 추천 시스템을 구현하게 된다면 NoSQL 을 선택하겠다.
    추천 시스템의 경우 사용자의 새로운 행동 데이터를 추가하는 경우가 잦은데, RDB 를 활용할 경우 스키마의 변경이 어렵고
    JSON 이나 동적 형식을 가지는 데이터를 관리하기가 어렵다.

### **3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.**
A. 트랜잭션이란 데이터베이스에서 처리하는 하나의 논리적인 작업 단위를 말한다.
트랜잭션의 특징으로 ACID 원칙이 있다.
- ACID 원칙
  - Atomic: 하나의 트랜잭션은 성공 | 실패 두 가지 중 하나의 상태만 가져야 한다.
  - Consistency: 트랜잭션의 시작 전 후 상태는 일관되어야 한다.
  - Isolation: 하나의 트랜잭션이 다른 트랜잭션에 간섭하지 않고 독립된 상태에서 진행되어야 한다.
  - Durability: 트랜잭션이 일어났다면 그 결과는 지속되어야 한다.

- **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**
  1. 로그(Log): 트랜잭션과 관련된 모든 변경 사항은 먼저 로그에 기록되고, 그 후 실제 데이터베이스에 적용된다. 시스템 장애가 발생하면 해당 로그를 사용해 데이터베이스를 이전의 상태로 복구할 수 있다.
  2. 체크포인트(Checkpoint): 특정 조건 하에서 DBMS 가 자동으로 수행하는 연산으로, 이 시점의 데이터베이스 상태를 디스크에 안전하게 저장한다.

- **트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?**
  - 트랜잭션은 데이터베이스에서 데이터의 일관성과 무결성을 보장하기 위해 사용된다. 주로 결제, 은행 업무, 재고 관리 등에 활용된다.
  - 프로젝트를 진행하면서 결제 시스템 작업을 수행하기 위해 트랜잭션을 활용하였다.
    1. 사용자 계좌에서 금액 차감 (또는 카드 결제)
    2. 재고 감소
    3. 주문 정보 저장
    
    결제 시 위 세 작업이 원자적으로 실행되어야 한다. 계좌에서 돈은 빠져나갔는데 재고가 감소하지 않거나, 재고가 없는데도 결제가 완료되는 오버셀링 문제 등과 같이 일부만 성공하고 나머지가 실패하면 데이터의 불일치가 발생하기 때문이다.
    이를 방지하기 위해 트랜잭션을 사용하였다.

- **읽기에는 트랜잭션을 걸지 않아도 될까요?**
  - 일반적인 단일 읽기 작업의 경우 트랜잭션을 생략해도 무방하나, 상황에 따라 읽기 작업에도 트랜잭션이 필요할 수 있다.
  - 복수의 읽기 작업이 일관된 데이터를 읽어야할 때 활용하거나, 트랜잭션을 사용해 중간에 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지할 수 있다.
  - 예를 들어 금융 시스템에서 계좌 잔액을 조회할 때 송금, 이체 등이 동시에 발생하여도 잔액을 정확히 읽어내기 위해 트랜잭션을 사용할 수 있다.

### **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**
A. 트랜잭션 격리 레벨이란 SQL 표준에서 정의한 네 가지 단계가 있으며, 각 단계는 이상 현상을 허용하는 정도에 따라 구분된다.
- 트랜잭션 격리 레벨
  1. Read Uncommitted: 가장 낮은 격리 수준. 트랜잭션이 커밋되지 않은 데이터를 읽는 것을 허용.
     - 허용되는 이상 현상: Dirty Read, Non-Repeat Read, Phantom Read
  2. Read Committed: 트랜잭션이 커밋된 데이터만 읽을 수 있도록 보장.
     - 허용되는 이상 현상: Non-Repeat Read, Phantom Read
  3. Repeatable Read: 트랜잭션 내에서 동일한 데이터를 반복적으로 읽을 때, 항상 동일한 결과를 반환하도록 보장.
     - 허용되는 이상 현상: Phantom Read
  4. Serializable: 가장 높은 격리 수준. 트랜잭션이 직렬적으로 실행되는 것처럼 보이도록 보장. 허용되는 이상현상이 없다. (모두 방지)
- 이상 현상 
  1. Dirty Read: 여러 트랜잭션이 실행되는 과정에서 아직 커밋되지 않은 데이터를 읽었을 때의 이상 현상.
  2. Non-Repeat Read: 두 번의 읽기 연산을 수행하는 트랜잭션을 실행할 때 다른 트랜잭션에 의해 각 연산의 결과가 달라지는 이상 현상.
  3. Phantom Read: 두 번의 읽기 연산을 수행하는 트랜잭션을 실행할 때 다른 트랜잭션에 의해 첫 번째 읽기 연산에서 보이지 않던 데이터가 두 번째 읽기 연산에서 보이는 이상 현상.

- **모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**
  - 모든 DBMS가 4가지 트랜잭션 격리 수준을 완벽히 구현하지는 않는다.
    이는 DBMS마다 성능 최적화와 설계 철학이 다르기 때문이며, 높은 격리 수준(특히 SERIALIZABLE)은 성능 저하와 동시성 처리 한계를 초래할 수 있기 때문이다.
    따라서 일부 DBMS는 낮은 격리 수준을 기본으로 제공하거나 높은 수준은 부분적으로만 지원한다.

- **만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.**
   - Undo 영역은 UPDATE 나 DELETE 로 데이터를 변경했을 때 변경되기 이전의 데이터를 보관하는 영역이다.
   - Redo 영역은 DB 상의 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일이 저장되는 영역이다.

- **그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?**
  - 스토리지 엔진은 DBMS 가 데이터를 삽입, 추출, 업데이트, 삭제(= CRUD)하는데 사용하는 기본 소프트웨어 컴포넌트이다.
  - 즉, DB 에서 데이터를 어떻게 저장하고 접근할 것인지에 대한 기능을 제공한다.

### **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**
A.  인덱스란 추가적인 쓰기 작업과 저장 공간을 활용해 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.
    인덱스를 활용하면 조회/수정/삭제의 성능이 향상되지만, 입력/삭제/수정이 빈번하게 발생하는 속성에 인덱스를 걸면 성능이 오히려 저하될 수 있다.

- **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
  - 수정이 잦은 경우 실제 데이터보다 인덱스의 크기가 커져 부하가 발생하기 쉽기 때문이다.
  1. INSERT(데이터 삽입): 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 정렬하여 저장하기 때문에 성능 저하가 발생한다.
  2. DELETE(데이터 삭제): 테이블에서만 삭제되고, 인덱스 테이블에는 여전히 남아 있어서 쿼리 수행 속도가 저하된다.
  3. UPDATE(데이터 수정): 인덱스에는 UPDATE 가 없기 때문에, DELETE - INSERT 두 작업이 수행되어 부하가 발생한다.
  
- **앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?**
  - 인덱스를 사용하지 않기로 선택하더라도 모든 작업이 위 정책을 따르지는 않는다. 데이터베이스는 최적화 전략에 따라 인덱스가 없을 때
    테이블을 풀 스캔하는 방식을 사용하며, 이는 수정 작업의 부하를 줄일 수 있지만 읽기 성능은 저하될 수 있다.
  - 결과적으로 인덱스 사용 여부는 작업의 특성과 읽기 / 쓰기 비율에 따라 결정된다.
  
- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
  - ORDER BY:
    - 인덱스가 존재하는 경우: 인덱스 컬럼을 기준으로 정렬, 따로 처리가 필요 없다.
    - 존재하지 않는 경우: 데이터를 읽어온 후 메모리 공간을 이용해 정렬한다.
  - GROUP BY:
    - 인덱스가 존재하는 경우: 마찬가지로 인덱스를 활용해 스캔하므로 따로 처리가 필요 없다.
    - 존재하지 않는 경우: `Using Temporary` 임시 테이블을 사용하여 처리한다.

- **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
  - 기본키와 인덱스는 다른 개념이다.
  - 기본키: 인덱스가 자동으로 적용되며, 개념적인 값으로 레코드의 유일성을 보장하지만 물리적으로는 저장되지 않는 논리적 개념이다.
  - 인덱스: 레코드의 유일성을 보장하지 않고, 단지 탐색을 빠르게 해주는 역할을 하며 별도의 디스크 공간에 저장된다.

- **그렇다면 외래키는요?**
  - 외래키는 기본키와 연결된 값으로, 참조 무결성을 보장하기 위한 논리적 제약 조건이다.
  - 마찬가지로 인덱스와는 다르며, 자동으로 인덱스가 생성되지는 않지만 성능 최적화를 위해 수동으로 인덱스를 생성하는 것이 일반적이다.
  
- **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
  - 인덱스는 데이터의 물리적 저장에 영향을 미치지 않는다.
  - 데이터는 일반적으로 삽입된 순서나 선언된 테이블 정책에 따라 저장된다.
  
- **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**
  - NoSQL 도 인덱스를 지원한다. (예: MongoDB 는 기본적으로 _id 필드에 인덱스를 생성한다) 
  - RDB 보다 유연하게 설계되어 문서형 데이터나 비정형 데이터의 검색을 최적화하는 데 초점이 맞춰져 있는 반면,
  - RDB 의 인덱스는 정형 데이터와 관계 모델을 기반으로 설계된다.

- **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**
  - 복합 인덱스 (A, B) 는 A 를 기준으로 정렬되기 때문에 B 조건만으로는 인덱스를 효율적으로 사용할 수 없다.
  - A 조건이 함께 사용될 때 인덱스를 활용할 수 있다.

### **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

- **이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?**
- **마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?**
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
- **샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**

### **7. 정규화가 무엇인가요?**

- **정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**
- **각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.**
- **정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.**

### **8. View가 무엇이고, 언제 사용할 수 있나요?**
A. View 란 가상의 테이블로, 일반 테이블로 사용하지만 사용자에게 보여줄 수 있는 정보만 따로 보여줄 수 있다.
기본 테이블로부터 유도된 가상 테이블이기 때문에 저장 장치 내에 물리적으로 존재하지 않으며 한 번 저장해두면 재활용할 수 있다.
따라서 민감한 데이터를 관리하는 경우 필요한 정보를 제공하기 위한 `보안성 강화` 목적, 복잡한 쿼리를 단순화(JOIN 문 감소)하고 재사용하기 위한 `편리성`, 
테이블 구조가 변경되더라도 View 를 통해 기존 인터페이스를 유지하기 위한 `캡슐화` 목적으로 사용된다.

- **그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?**
  - 결국 가상 테이블이기 때문에 반영되지 않는다.
  - 하지만 아래와 같은 경우에는 반영될 수 있다. 
    1. View 가 단일 테이블에 직접 매핑되는 경우
    2. View 에 포함된 컬럼이 기본 테이블의 수정 가능한 컬럼인 경우
    3. View 에 복잡한 연산(집계, JOIN, 서브쿼리 등)이 포함되지 않은 경우

### **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

- **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
- **그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?**
- **앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?**
- **3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.**

### **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
- **DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?**
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**

### **11. DB Locking에 대해 설명해 주세요.**

- **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**
- **물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?**

### **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**
A. 트래픽이 증가하면 데이터베이스의 성능 저하, 응답 지연, 서비스 장애 등의 문제가 생길 수 있다.
- 해결 방식
  1. 수직 확장: 기존 데이터베이스 서버의 하드웨어 성능을 업그레이드하는 방식.
  2. 수평 확장: 데이터베이스의 서버를 여러 대로 분산하여 트래픽을 나누는 방식.
  3. 데이터베이스 캐싱: 자주 조회되는 데이터를 메모리 캐시에 저장하여 DB 의 부하를 줄이는 방식.
  4. 쿼리 최적화: 쿼리의 실행 계획을 개선하고, 불필요한 쿼리를 줄이는 방식.

- **DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?**
  - 캐싱 도입: 자주 조회되는 데이터를 메모리에 캐싱
  - 쿼리 최적화: 인덱스 추가, 불필요한 조회 제거, 효율적인 데이터 모델링
  - 데이터 아카이빙: 오래된 데이터를 별도 저장소로 이동
  - 서버 자원 업그레이드: CPU, RAM, 디스크 증설(수직 확장)

### **13. Schema가 무엇인가요?**
A. 데이터베이스 내에 어떤 구조로 데이터가 저장되는가를 나타내는 데이터베이스 구조를 스키마라고 정의한다.
- 데이터베이스 내에서 데이터가 구성되는 방식.
- 개체, 개체의 속성, 개체들의 관계, 제약 조건 등을 명세한 것.

- **Schema의 3계층에 대해 설명해 주세요.**
  - 외부 스키마: 사용자 입장에서 바라보는 스키마. 업무 상 관련이 있는 데이터에 접근하는 것.
    - 사용자가 데이터베이스에 조회 쿼리를 날려서 보게 되는 데이터들, 조회해서 나온 테이블 그 자체를 말한다.
  - 개념 스키마: 설계자 관점에서 바라보는 스키마. 사용자 전체 집단의 데이터베이스 구조. 전체 데이터베이스 내의 규칙과 구조를 표현한다.
    - 데이터베이싀 전체의 논리구조. 여러 엔티티, 엔티티의 관계 등 테이블 그 자체를 보는 것이 아닌 데이터베이스를 전체적으로 크게 바라본 형태.
  - 내부 스키마: 개발자 관점에서 바라보는 스키마. 데이터베이스의 물리적 저장구조.
    - 데이터 저장구조, 레코드 구조, 필드 정의, 인덱스 등. 개발자가 사용하는 데이터베이스 테이블 그 자체의 물리적인 구조를 얘기하는 것.
    - 실질적으로 테이블에 대해 조작할 때 필요한 것들을 뜻한다.

### **14. DB의 Connection Pool에 대해 설명해 주세요.**

- **DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.**

### **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

- **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
- **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?**

### **16. SQL Injection에 대해 설명해 주세요.**
A. SQL Injection(SQL 인젝션)이란 악의적인 사용자가 SQL 쿼리 조작을 통해 데이터베이스에 비정상적으로 접근하거나 조작하는 보안 취약점을 말한다.
공격자는 입력 필드에 SQL 코드를 삽입해 권한 없는 데이터를 조회하거나 삭제, 수정 등의 작업을 수행할 수 있다.
```java
String userInput = "123 OR 1=1"; // 악의적 입력
String query = "SELECT * FROM users WHERE id = '" + userInput + "'";
```
- 위 코드에 123 OR 1=1을 입력하면, 항상 1=1이 참이므로 모든 데이터가 조회된다.
- 공격자가 '; DROP TABLE users; -- 와 같은 코드를 입력할 경우, 데이터베이스 삭제까지 가능하다.

- **그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?**
  1. Prepared Statement (준비된 문장)
  - SQL 쿼리와 사용자 입력을 분리하여, 쿼리를 먼저 컴파일하고 이후에 데이터를 바인딩.
  - 사용자 입력을 문자열이 아닌 데이터로 처리.
  ```java
  PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
  pstmt.setString(1, userInput); // 입력 값을 안전하게 바인딩
  ResultSet rs = pstmt.executeQuery();
  ``` 
  2.  ORM (Hibernate, JPA 등)
  - ORM 프레임워크는 데이터베이스 쿼리를 직접 작성하지 않고, 메서드 체인 방식으로 제공.
  ```java
  User user = entityManager.find(User.class, userInput);
  ```
  3. 입력 값 검증 및 인코딩: 사용자 입력을 화이트리스트 방식으로 검증하거나, 특수 문자를 인코딩.
  - 숫자만 입력받는 경우, ^[0-9]+$ 정규표현식 사용.
  4. 최소 권한 원칙 (Principle of Least Privilege): 데이터베이스 계정에 최소한의 권한만 부여하여, SQL Injection 발생 시 피해를 최소화.