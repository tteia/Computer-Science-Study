## Java

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️
A. JVM(Java Virtual Machine)이란 Java 를 실행하기 위한 가상 환경을 뜻한다. 자바 프로그램 실행환경을 만들어주는 소프트웨어인 것이다.
컴파일러를 통해 작성된 소스 코드를 기계어로 변환하는 대신 중간 단계의 `.class` 바이트코드라는 형식으로 컴파일하고,
이 바이트코드는 JVM 에 의해 해석되어 프로그램이 실행된다.

- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 다른 언어도 JVM 위에 올릴 수 있다. JVM 위에서 실행될 수 있는 언어를 JVM 언어라고 부르는데 `Scala`, `Kotlin`, `Groovy` 등이 JVM 언어에 속한다.
  - 각자의 특성을 가지고 있는 언어들도 JVM 위에서 실행되므로 자바의 라이브러리와 프레임워크를 활용할 수 있고, JVM 의 메모리 관리와 성능 최적화 같은 기능을 이해할 수 있다.

- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**
  - 특정 상황에서 다른 도구(GraalVM, Kotlin/Native)들을 활용하면 일반적인 코드로 컴파일될 수도 있다.
  - 하지만 일반적으로 JVM 언어를 사용하는 주요 이유는 JVM 의 장점을 활용하기 위한 것이므로 JVM 계열 언어를 네이티브 코드로 컴파일하는 것은 일반적인 경우는 아니다.

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - 일반적인 운영 체제의 프로세스 계층 관계를 고려할 때, JVM 과 그 내부에서 실행되고 있는 프로그램은 부모-자식 관계라고 보기보다는,
    JVM 이 프로세스를 호스팅하는 쉘(shell, 사용자의 명령어를 해석하고 운영체제가 알아들을 수 있게 지시해주는 것) 역할을 하는 것에 가깝다.

- **Java bytecode란 무엇인가요?**
  - Java bytecode 란 자바 소스 코드를 컴파일러를 통해 변환한 중간 코드 형태이다.
  - JVM 이 이해하고 실행할 수 있는 명령어로 이루어져 있으며, `.class` 파일에 저장된다.
  
- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일 언어와 인터프리터 언어의 특징을 모두 가지고 있다.
    - 컴파일 단계: 자바 소스 코드가 먼저 바이트코드로 컴파일 된다.
    - 인터프리트 단계: 컴파일된 바이트코드는 JVM 에 의해 해석되어 실행된다.
  - 따라서 자바는 바이트코드를 인터프리팅하는 방식의 컴파일 언어라고 할 수 있다.

- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**
  1. 소스 코드 컴파일: 자바 소스 파일(.java)이 바이트코드(.class)로 변환된다.
  2. 클래스 로딩: JVM 의 ClassLoader 가 바이트코드를 메모리에 로드한다.
  3. 바이트코드 실행: JVM 이 바이트코드를 해석하고 실행한다.
  4. 메모리 관리: JVM 의 Garbage Collector 가 불필요한 객체들을 자동으로 메모리에서 해제한다.

- **JVM의 구조에 대해 설명해주세요.**
  1. ClassLoader: 바이트코드를 메모리에 로드한다. 
  2. Runtime Data Area: 실행 시 필요한 메모리를 관리한다. 
  3. Execution Engine: 바이트코드를 해석하고 실행한다. 
  4. Native Method Interface (JNI): 네이티브 코드(Java 외 언어)와의 상호작용을 지원한다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  - Runtime Data Area 영역이란 JVM 이 실행 중에 사용하는 메모리 영역을 말한다.
  - 주요 영역
    - Method Area: 클래스 정보, static 변수 저장 
    - Heap: 객체와 인스턴스 변수 저장 
    - Stack: 메서드 호출 시 생성되는 스택 프레임 저장 
    - PC Register: 현재 실행 중인 명령어의 주소 저장 
    - Native Method Stack: 네이티브 메서드 실행 시 사용되는 스택

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**
  - Stack: 메서드 실행 시 생성되는 로컬 변수와 호출 정보를 저장한다. 메서드가 종료되면 메모리가 해제된다.
  - Heap: 객체가 저장되며, Garbage Collector 에 의해 메모리 관리가 이루어진다.
  - Stack 은 메서드 단위로 생성/소멸되며, Heap 은 객체의 생명 주기에 따라 관리된다.

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**
  - 예를 들어 두 스레드가 하나의 공유 객체의 값을 동시에 수정하려고 하면 문제가 발생할 수 있다.
    ```java
    public class Counter {
    private int count = 0;

    public void increment() {
        count++; // 동시 접근 시 값이 꼬일 수 있음
      }
    }
    ```
    두 스레드가 `increment()` 메서드를 동시에 호출한다면, count++ 연산에 대해 데이터 불일치 문제가 발생할 수 있다.

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**
  - 메서드 내부에서 선언된 참조형 변수는 Stack 영역에 저장된다. 하지만 참조형 변수가 가리키는 객체 자체는 Heap 영역에 저장된다.
  - 따라서 메서드 종료 시 선언된 참조형 변수는 스택에서 사라지지만, Heap 영역 안에 있는 객체 그 자체는 Garbage Collector 가 제거할 때까지 남아 있다.

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**
  - Stack: 메서드 호출 시 생성되는 스택 프레임, 로컬 변수, 메서드 실행 정보 
  - Heap: 객체와 객체의 인스턴스 변수

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**
  - 기본형 데이터 타입: Stack 영역에 실제 값이 저장된다. 
  - 참조형 데이터 타입: 참조 변수는 Stack 에 저장되지만, 객체의 실제 데이터는 Heap 영역에 저장된다.

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**
  - `p` (참조 변수): Stack 영역에 저장된다.
  - `new Person() 객체`: Heap 영역에 저장된다.

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 스택 프레임은 메서드 호출과 함께 생성되고, 종료 시 자동으로 제거된다.
  - 반면 힙 영역의 객체는 다른 객체나 스레드에서 참조하고 있을 수 있기 때문에 Garbage Collector 가 필요 없다고 판단할 때까지 남아있다.

- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**
  - 공통점: 두 영역 모두 JVM 메모리의 일부이며 객체나 데이터를 저장한다.
  - 차이점
    - Static 영역: 클래스의 static 변수와 메서드가 저장되며, 클래스 로딩 시 생성된다.
    - Heap 영역: 객체와 인스턴스 변수가 저장되며, 런타임 시 동적 생성된다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
A. final 키워드는 변수, 메서드, 클래스에 사용할 수 있으며 선언된 대상의 변경을 금지한다.
컴파일러가 변수나 메서드를 변경할 수 없다는 것을 알고 코드를 더 효과적으로 최적화할 수 있다.
변경을 방지해 코드의 안정성과 최적화 가능성을 높이는 것이다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - final 키워드를 사용한다고 해서 큰 성능 차이가 발생하지는 않으나, 컴파일러 과정에서 최적화를 수행해 속도가 조금 더 빠르다.
  - 컴파일러는 변수를 호출하는 대신 실제 값을 직접 대입하는 방식으로 최적화 한다.

### 3. 변수는 어떤 것인가요?
A. 변수는 데이터를 저장하는 공간으로, 프로그램 실행 중 값이 변할 수 있다.
변수는 메모리의 특정 영역에 저장되며 변수 이름을 통해 해당 메모리 위치에 접근할 수 있다.

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**
  - 참조형 변수는 객체를 가리키는 주소값(참조값)만 저장한다.
  - 메모리 효율성: 객체는 크기가 클 수 있기 때문에 객체 전체를 저장하면 메모리를 많이 사용하므로 효율적으로 주소값만 저장한다.
  - 유연성: 참조값을 통해 객체의 위치를 추적하므로 객체를 동적으로 관리할 수 있다.

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**
  - 기본형 변수는 단순한 데이터(숫자, 문자 등)를 저장하기 때문에 메모리 크기가 작고 고정적이다.
  - 속도: 스택 영역에 저장하면 접근 속도가 빠르기 때문에 성능이 향상시킬 수 있다.
  - 관리 용이: 스택은 메서드 호출과 함께 생성 및 소멸되므로, 기본형 변수의 생명주기를 명확하고 효율적으로 관리할 수 있다.

- **변수와 상수의 차이는 무엇인가요?**
  - 변수: 값이 변경 가능하다. 실행 중에 다른 값으로 변경할 수 있다.
  - 상수: 값의 변경이 불가능하다.`final` 키워드를 통해 한 번 할당된 값을 수정할 수 없도록 한다.
  ```java
  // 변수
  int x = 5;
  x = 10; // 값 변경 가능
  
  // 상수
  final int x = 10;
  x = 20; // 컴파일 에러 발생
  ```

### 4. 부동소수점이 무엇인가요?
A. 부동 소수점이란 소수점을 고정하지 않고 유동적으로 움직이게 하여 실수를 표현하는 방식이다.
`float` 와 `double` 이 이에 해당한다.

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**
  - 부동 소수점은 정확한 값을 표현하지 못하고 근사값으로 저장하기 때문에, 소수점 계산 시 오차가 발생할 수 있다.
  - ex.
    ```java
    double a = 0.1;
    double b = 0.2;
    System.out(a + b); // 결과 = 0.30000000000000004
    ```

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**
  - 자바에서 정확한 실수 계산이 필요한 경우 `BigDecimal` 을 활용한다.
  - 부동소수점이 아닌 정확한 수의 표현을 지원하며, 소수점 오차 없이 정확한 계산이 가능하다.
  - ex.
    ```java
    BigDecimal a = new BigDecimal("0.1");
    BigDecimal a = new BigDecimal("0.2");
    BigDecimal sum = a.add(b);
    System.out(sum); // 결과 = 0.3
    ```

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**
  - BigDecimal 은 실수를 문자열 또는 정수 형태로 저장하고, 소수점 위치를 별도로 관리한다.
    - 내부적으로 `Scale` 을 사용해 소수를 저장한다.
    - ex.
      ```java
      BigDecimal num = new BigDecimal("123.45");
      // 정수 값: 12345
      // Scale: 2
      // 결과적으로 123.45는 (12345, 2)로 저장됨.
      ```

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?
A. `==`: 기본형 데이터 타입의 값을 비교하거나, 참조형 데이터 타입의 메모리 주소(참조값)를 비교한다.
`equals`: Object 클래스의 메서드로, 기본적으로 메모리 주소를 비교한다.

- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**
  ```java
  public boolean equals(Object obj) {
    return (this == obj);
  }
  ```
  - 기본 구현은 `==` 와 동일하게 두 객체의 참조값을 비교한다.

- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```
  - 출력 결과: `false`
  - `new Integer(3)` 은 항상 새로운 객체를 생성하므로, a 와 b 는 서로 다른 메모리 주소를 참조한다.
  - 따라서 `==` 는 두 객체의 참조값이 다르다고 평가하여 false 를 반환한다.
  
- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**
  - `equals()`: 객체의 논리적 동등성(내용)을 비교한다.
  - `hashCode()`: 객체의 해시 값(고유 숫자)을 반환한다.
    - 객체가 HashMap, HashSet 등에 저장될 때 해시코드를 사용해 검색 및 비교 성능을 향상시킨다.
  - 두 객체가 equals() 로 같다면 반드시 같은 haseCode 를 반환해야 한다.
  - 반면 두 객체가 같은 hashCode 를 가졌더라도 equals() 는 다를 수 있다.
  
- **`hashCode()` 의 용도는 무엇인가요?**
  - HashMap, HashSet 과 같은 해시 기반 컬렉션에서 객체를 효율적으로 저장하고 검색하기 위해 사용된다.
  - hashCode() 는 객체를 분류하는 데 사용되며, 동일한 해시코드를 가진 객체는 같은 버킷에 저장된다.

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**
  1. 일관성: 동일한 객체에서 호출되는 hashCode 는 항상 같은 값을 반환해야 한다.
  2. 고유성: 가능한 한 다른 객체들이 서로 다른 해시코드를 가지게 하여 충돌을 줄인다.

- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**
  1. 대칭성: a.equals(b) 이면 b.equals(a) 도 true 여야 한다.
  2. 일관성: 객체가 변하지 않으면 equals() 결과도 변하지 않아야 한다.
  3. a.equals(null) 은 항상 false 를 반환한다.

- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**
  - 객체의 주소값을 비교하기 위해서는 `==` 연산자를 통해 두 객체의 메모리 주소를 직접 비교할 것이다.

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?
A. 다형성이란 하나의 객체가 여러 형태를 가질 수 있음을 의미한다.
자바에서는 주로 메서드 오버라이딩과 인터페이스 구현을 통해 다형성을 구현한다.
- 메서드 오버라이딩을 활용해 부모 클래스의 메서드를 자식 클래스에서 재정의할 수 있다.
- 인터페이스를 활용해 여러 클래스가 동일 메서드를 구현할 수 있으며, 메서드 호출 시 객체 타입에 따라 다른 동작을 수행할 수 있다.
  ```java
  class Animal {
      void sound() {
          System.out.println("동물이 소리를 낸다.");
      }
  }
  
  class Dog extends Animal {
      @Override
      void sound() {
          System.out.println("멍멍!");
      }
  }
  
  class Cat extends Animal {
      @Override
      void sound() {
          System.out.println("야옹!");
      }
  }
  ```

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?
- 인터페이스: 행동(기능)을 정의하며 다중 구현이 가능하다.
  - 추상 메서드, 상수, `default`/`static` 메서드 포함.
- 추상 클래스: 공통 특성과 기능을 정의하며 단일 상속만 가능하다.
  - 추상 메서드, 일반 메서드, 인스턴스 필드, 생성자 포함.
A. 추상 클래스는 생성자와 인스턴스 필드(변수)를 가질 수 있지만, 인터페이스는 가질 수 없다.
또 인터페이스는 `default`/`static` 메서드를 제공하는 반면, 추상 클래스는 이를 필드와 메서드로 대체한다.

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**
  - 클래스는 구현된 코드(필드, 메서드)를 상속 받아 충돌 위험이 높으나, 인터페이스는 주로 행위(메서드 이름, 매개변수 목록)를 정의하므로 충돌 가능성이 낮기 때문이다.

- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**
  - 인터페이스에서 구현을 가진 메서드로, 기존 인터페이스에 새 기능을 추가할 때 구현체에 영향을 주지 않으려고 사용한다.

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**
  - 다중 상속의 문제점이 발생할 수 있다. 클래스가 두 개 이상의 인터페이스를 구현하는 경우 동일한 메서드의 `default method` 가 존재하면 충돌이 발생한다.
  - `default method` 는 인터페이스에서 구현된 메서드인데, 두 인터페이스의 `default method` 가 동일한 메서드명과 매개변수를 가진다면 클래스는 어떤 메서드를 상속받을지 명확하지 않기 때문이다.
  - 클래스에서 명시적으로 `default method`를 재정의하여 충돌을 해결해야 한다.

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.
- 상속(Inheritance): 기존 클래스(부모 클래스)의 모든 속성과 메서드를 상속받아 재사용하는 방법.
  - 장점1. 코드 재사용성: 부모 클래스의 코드를 그대로 사용 가능하며 확장 가능하다.
  - 장점2. 일관성 유지: 공통 기능을 부모 클래스에 정의하면, 자식 클래스에서 관리가 용이하다.
  - 장점3. 다형성 활용: 부모 클래스 타입으로 여러 자식 객체를 처리할 수 있어 코드 유연성이 높아진다.
- 조합(Composition): 한 클래스가 다른 클래스의 객체를 멤버 변수로 포함하여 기능을 재사용하는 방법.
  - 장점1. 유연성: 조합은 필요한 기능만 포함하므로, 불필요한 기능까지 상속받지 않는다.
  - 장점2. 캡슐화 강화: 포함된 객체의 내부 구현이 외부에 드러나지 않아 유지보수성이 높다.
  - 장점3. 구조적 독립성: 조합된 객체는 독립적으로 변경 가능하며, 이를 교체해도 큰 영향을 미치지 않는다.
- 상속은 `부모-자식` 처럼 하위 클래스로 확장, 공통 동작 공유 등이 필요할 때 사용한다.
- 조합은 독립적인 기능 조합이 필요해 클래스가 객체를 포함하는 경우 사용한다.

### 9. 리플렉션에 대해 설명해 주세요.
A. 리플렉션(Reflection) 이란 런타임 시점에 클래스, 메서드, 필드 등의 정보를 동적으로 탐색하고 조작할 수 있는 기능을 말한다.
자바에서는 `java.lang.reflect` 패키지를 통해 사용 가능하다.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**
  - 리플렉션은 비공개(private) 필드나 메서드에도 접근할 수 있어 캡슐화 원칙을 깨뜨릴 위험이 있고,
    프로그램의 동작을 예측하기 어렵게 하거나 민감한 데이터를 노출할 가능성이 있다.
  - 이에 대한 방지 방법으로, `Security Manager` 설정을 통해 리플렉션 사용을 제한하거나 민감한 코드에 대한 접근을 차단할 수 있다.
  - 메서드 호출을 제한하여 꼭 필요한 경우에만 최소한의 접근이 가능하도록 설정한다.

- **리플렉션을 언제 활용할 수 있을까요?**
1. 프레임워크 개발: 스프링, 하이버네이트 등 프레임워크에서 리플렉션을 통해 객체 의존성을 주입하거나 설정 파일을 읽어 처리한다.
2. 동적 객체 생성 및 호출: 런타임 시점에 클래스 이름을 알지 못해도 객체를 생성하거나 메서드를 호출해야할 때 사용한다.
3. 테스트 자동화: 단위 테스트 단계에서 비공개 메서드나 필드에 접근해 동작을 검증할 때 유용하다.

### 10. static class와 static method를 비교해 주세요.
- `static class`: 클래스 내부에 선언된 정적 클래스. 내부 클래스에서 주로 사용하며 외부 클래스의 인스턴스와 무관하게 동작 가능하다.
- `static method`: 객체와 무관하게 호출 가능한 정적 메서드. 모든 클래스에서 사용 가능한 유틸리티 메서드로 객체 없이 호출 가능하며, `this` 는 사용 불가하다.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?** 
  - 이점 
    1. 메모리 절약: `static` 은 클래스 로드 시 한 번만 메모리에 로드되어 여러 객체에 공유 가능하다.
    2. 객체 독립성: 객체 생성 없이 클래스 이름으로 바로 접근 가능하다.
    3. 유틸리티성 코드에 적합: 반복적으로 사용되는 메서드에 적합하다.
  - 제약
    1. 인스턴스 멤버 사용 불가: 객체가 필요 없는 특성상 인스턴스 변수나 메서드에 접근할 수 없다.
    2. 다형성 제한: static 메서드의 경우 오버라이딩이 불가능하여 다형성을 활용할 수 없다.

- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**
  - 클래스 로드 시점에 JVM 의 메서드 영역 메모리에 할당되어 객체가 생성되지 않아도 접근 가능해진다.
  - 컴파일 타임에 호출이 결정되며 다형성을 지원하지 않아 클래스 이름을 통해 직접 호출한다.

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.
A. `new` 키워드는 객체를 새로 생성할 때 사용하며, 메모리 할당, 생성자 호출, 클래스 정보 로드 등이 발생된다.
1. 메모리 할당: Heap 영역에 객체를 저장하기 위한 메모리 공간이 할당되며, 스택 영역에 객체의 참조값이 저장된다.
2. 생성자 호출: 생성자가 호출되어 객체의 초기화 작업이 수행된다. 생성자에서 필드를 초기화하거나 필요한 작업을 실행한다.
3. 클래스 정보 로드: JVM 이 해당 클래스가 메서드 영역에 로드되어 있는지 확인 후, 없다면 클래스 파일을 로드하고 메서드 영역에 저장한다.
```java
public class Main {
    public static void main(String[] args) {
        Person p = new Person("John", 25);
    }
}
```
1) `Person` 클래스가 메서드 영역에 로드된다.
2) `new` 키워드로 Heap 영역에 `Person` 객체가 생성된다.
3) `p` 변수는 Stack 영역에 참조값을 저장한다.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?
A. 스레드 풀(Thread Pool) 이란 미리 생성된 일정한 수의 스레드 집합이다. 작업이 요청되면 스레드 풀에서 스레드를 재사용해 작업을 처리한다.
스레드 풀은 많은 작업을 효율적으로 관리하므로 다수의 작업이 동시에 처리되어야 할 때 사용되며, 스레드 수를 제한하고 메모리 자원을 절약할 때 사용한다.
스레드 생성 및 제거의 오버헤드를 감소시켜 작업 처리 속도를 향상시키며, 시스템 과부하를 방지해 안정적으로 동작한다.
- 주요 특징
1. 스레드 재사용: 새 스레드를 생성하는 대신 기존 스레드를 재사용하여 성능을 최적화한다.
2. 리소스 제한: 생성 가능한 스레드의 수를 제한해 시스템 과부하를 방지한다.
3. 작업 큐: 작업 요청은 대기열에 쌓이고, 여유 스레드가 생기면 하나씩 처리된다.


### 13. Error 와 Exception 의 차이가 무엇인가요?
- Error: 자바 프로그램이 복구할 수 없는 문제. JVM 레벨의 오류로 프로그램이 실행을 계속할 수 없을 때 발생한다.
  - 예) `OutOfMemoryError`, `StackOverflowError`
- Exception: 프로그램에서 발생하는 일반적인 예외. 개발자가 처리하거나 복구할 수 있다.
  - 예) 파일이 존재하지 않거나 잘못된 입력 값

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**
  - 체크 예외(Checked Exception): 컴파일 타임에 검사되는 예외. 반드시 try-catch 나 throws 로 처리해야 한다.
    - 예) `IOException`, `SQLException`
  - 언체크 예외(Unchecked Exception): 런타임에 발생하는 예외. 처리하지 않아도 컴파일은 가능하다.
    - 예) `NullPointerException`, `ArithmeticException`

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**
A. JVM 의 Heap 영역에 더 이상 객체를 저장할 메모리가 없을 때 발생한다.
- 객체를 계속 생성하며 메모리를 해제하지 않는 경우
- 너무 많은 데이터(컬렉션, 배열 등)를 한 번에 처리하는 경우
필요 없는 객체를 명시적으로 null 로 지정하거나, 힙 크기를 늘리고 객체 패턴을 최적화하는 방법으로 해결할 수 있다.

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**
A. JVM 의 Stack 영역이 초과될 때 발생한다.
- 메서드 호출이 과도하게 깊어지는 경우 (ex.무한 재귀 호출)
- 너무 많은 로컬 변수를 사용하는 경우
재귀 호출을 반복문으로 변경하거나, 스택 크기를 늘리는 방법으로 해결할 수 있다.

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**
  - 체크 예외: 컴파일 타임에 처리 여부를 검사하기 때문에 프로그램이 예외 상황에 대비하도록 강제한다.
    - 파일 입출력, 네트워크 연결 등 외부 자원과의 작업은 실패 가능성이 높기 때문에 반드시 처리해야 한다.
  - 언체크 예외: 대부분 개발자의 실수로 발생하는 예외로 예외처리를 하지 않아도 프로그램 실행이 가능하며, 런타임에서 적절히 처리하거나 개선할 수 있다.
    - `NullPointerException` 은 null 체크를 통해 예방 가능


### 14. 자바에서 쓰레드를 생성하는 방법에는 어떤 것들이 있나요?

- **그렇다면 두 방법의 장단점은 무엇인가요?**

- **`Runnable` 인터페이스의 용도는 무엇인가요?**

- **왜 Thread 클래스의 `public static native Thread currentThread();` 는 static 으로 선언되어 있나요?**

- **쓰레드의 `start()` 과 `run()` 메서드는 어떤 차이가 있나요?**

- **아래 코드의 결과는 어떻게 될까요?**

  ```java
  class MyRunnable implements Runnable{
    public void run(){
      System.out.println("My Runnable is running");
      Thread currThread = Thread.currentThread();
      currThread.setName("thread in run method");
      System.out.println("Current thread in run : " + currThread.getName());
    }
  }

  class TestRunnable {
    public static void main(String[] args) {
      Thread thread = new Thread(new MyRunnable());
      thread.run();
      System.out.println("Current thread in main : " + Thread.currentThread().getName());
    }
  }
  ```

- **새로 생성된 쓰레드의 호출 스택은 언제 사라질까요?**

- **Callable 과 Runnable 의 차이는 무엇인가요? 왜 Callable 과 Future 인터페이스가 생겼나요?**

- **ExecutorService, Future 는 각각 무엇이며 어떤 용도로 쓰이나요?**

### 15. 쓰레드의 상태값에는 어떤 것들이 있나요?

- **`WAITING` 과 `BLOCKED` 의 차이는 무엇인가요?**

- **왜 `sleep()` 과 `yield()` 는 static 메서드인가요?**

- **`yield()` 과 `join()` 의 차이점은 무엇인가요?**

- **`sleep()` 과 `wait()` 의 차이점과 공통점은 무엇인가요?**

### 16. 쓰레드의 동기화는 무엇이며, 동기화에 사용되는 방법들은 어떤 것이 있나요?

- **`synchronized` 에 의한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`wait()`와 `notify()` 를 이용한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`java.util.concurrent.locks` 에 있는 Lock 과 Condition 은 위의 문제들을 어떻게 해결했나요?**

- **`volatile` 키워드는 어떻게 변수에 대한 읽기와 쓰기를 동기화하나요?**

### 17. `ConcurrentHashMap` 은 무엇이며 어떻게 thread-safe 를 보장하나요?

- **버킷이 비어있는 경우, 새로운 노드를 추가할 때는 어떻게 락을 걸지 않고 thread-safe 를 보장할 수 있나요?**

### 18. 함수형 프로그래밍은 무엇이며, 왜 필요한가요?

- **함수형 프로그래밍의 특징을 설명해주세요.**

- **자바에서는 어떻게 함수형 프로그래밍을 할 수 있나요?**

- **`@FunctionalInterface` 어노테이션의 역할은 무엇인가요?**

- **람다식과 함수형 인터페이스의 관계는 무엇인가요?**

- **람다표현식과 익명클래스의 차이는 무엇인가요?**

- **자바에서 미리 함수형 인터페이스를 정의해놓은 이유는 무엇인가요?**

### 19. 자바에서 I/O가 느린이유는 무엇인가요?

- **운영체제에서 I/O는 어떻게 동작하나요?**

- **자바 IO 패키지가 OS의 I/O 보다 훨씬 느린 이유는 무엇인가요?**

- **자바에서 NIO 패키지는 왜 IO 패키지에 비해 속도가 빠른가요?**

- **그러면 IO 가 무조건 나쁜 것일까요?**

### 20. 쓰레드풀, 커넥션풀 등 여러 Pool 이 있는데, 이들의 용도는 무엇일까요?

### 21. 쓰레드 로컬(Thread Local) 은 무엇인가요?

### 22. Stream 에서 Map,flatMap 과 Optional 에서 Map, flatMap의 차이는 무엇인가요?