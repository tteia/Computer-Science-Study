## Java

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️
A. JVM(Java Virtual Machine)이란 Java 를 실행하기 위한 가상 환경을 뜻한다. 자바 프로그램 실행환경을 만들어주는 소프트웨어인 것이다.
컴파일러를 통해 작성된 소스 코드를 기계어로 변환하는 대신 중간 단계의 `.class` 바이트코드라는 형식으로 컴파일하고,
이 바이트코드는 JVM 에 의해 해석되어 프로그램이 실행된다.

- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 다른 언어도 JVM 위에 올릴 수 있다. JVM 위에서 실행될 수 있는 언어를 JVM 언어라고 부르는데 `Scala`, `Kotlin`, `Groovy` 등이 JVM 언어에 속한다.
  - 각자의 특성을 가지고 있는 언어들도 JVM 위에서 실행되므로 자바의 라이브러리와 프레임워크를 활용할 수 있고, JVM 의 메모리 관리와 성능 최적화 같은 기능을 이해할 수 있다.

- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**
  - 특정 상황에서 다른 도구(GraalVM, Kotlin/Native)들을 활용하면 일반적인 코드로 컴파일될 수도 있다.
  - 하지만 일반적으로 JVM 언어를 사용하는 주요 이유는 JVM 의 장점을 활용하기 위한 것이므로 JVM 계열 언어를 네이티브 코드로 컴파일하는 것은 일반적인 경우는 아니다.

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - 일반적인 운영 체제의 프로세스 계층 관계를 고려할 때, JVM 과 그 내부에서 실행되고 있는 프로그램은 부모-자식 관계라고 보기보다는,
    JVM 이 프로세스를 호스팅하는 쉘(shell, 사용자의 명령어를 해석하고 운영체제가 알아들을 수 있게 지시해주는 것) 역할을 하는 것에 가깝다.

- **Java bytecode란 무엇인가요?**
  - Java bytecode 란 자바 소스 코드를 컴파일러를 통해 변환한 중간 코드 형태이다.
  - JVM 이 이해하고 실행할 수 있는 명령어로 이루어져 있으며, `.class` 파일에 저장된다.
  
- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일 언어와 인터프리터 언어의 특징을 모두 가지고 있다.
    - 컴파일 단계: 자바 소스 코드가 먼저 바이트코드로 컴파일 된다.
    - 인터프리트 단계: 컴파일된 바이트코드는 JVM 에 의해 해석되어 실행된다.
  - 따라서 자바는 바이트코드를 인터프리팅하는 방식의 컴파일 언어라고 할 수 있다.

- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**
  1. 소스 코드 컴파일: 자바 소스 파일(.java)이 바이트코드(.class)로 변환된다.
  2. 클래스 로딩: JVM 의 ClassLoader 가 바이트코드를 메모리에 로드한다.
  3. 바이트코드 실행: JVM 이 바이트코드를 해석하고 실행한다.
  4. 메모리 관리: JVM 의 Garbage Collector 가 불필요한 객체들을 자동으로 메모리에서 해제한다.

- **JVM의 구조에 대해 설명해주세요.**
  1. ClassLoader: 바이트코드를 메모리에 로드한다. 
  2. Runtime Data Area: 실행 시 필요한 메모리를 관리한다. 
  3. Execution Engine: 바이트코드를 해석하고 실행한다. 
  4. Native Method Interface (JNI): 네이티브 코드(Java 외 언어)와의 상호작용을 지원한다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  - Runtime Data Area 영역이란 JVM 이 실행 중에 사용하는 메모리 영역을 말한다.
  - 주요 영역
    - Method Area: 클래스 정보, static 변수 저장 
    - Heap: 객체와 인스턴스 변수 저장 
    - Stack: 메서드 호출 시 생성되는 스택 프레임 저장 
    - PC Register: 현재 실행 중인 명령어의 주소 저장 
    - Native Method Stack: 네이티브 메서드 실행 시 사용되는 스택

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**
  - Stack: 메서드 실행 시 생성되는 로컬 변수와 호출 정보를 저장한다. 메서드가 종료되면 메모리가 해제된다.
  - Heap: 객체가 저장되며, Garbage Collector 에 의해 메모리 관리가 이루어진다.
  - Stack 은 메서드 단위로 생성/소멸되며, Heap 은 객체의 생명 주기에 따라 관리된다.

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**
  - 예를 들어 두 스레드가 하나의 공유 객체의 값을 동시에 수정하려고 하면 문제가 발생할 수 있다.
    ```java
    public class Counter {
    private int count = 0;

    public void increment() {
        count++; // 동시 접근 시 값이 꼬일 수 있음
      }
    }
    ```
    두 스레드가 `increment()` 메서드를 동시에 호출한다면, count++ 연산에 대해 데이터 불일치 문제가 발생할 수 있다.

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**
  - 메서드 내부에서 선언된 참조형 변수는 Stack 영역에 저장된다. 하지만 참조형 변수가 가리키는 객체 자체는 Heap 영역에 저장된다.
  - 따라서 메서드 종료 시 선언된 참조형 변수는 스택에서 사라지지만, Heap 영역 안에 있는 객체 그 자체는 Garbage Collector 가 제거할 때까지 남아 있다.

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**
  - Stack: 메서드 호출 시 생성되는 스택 프레임, 로컬 변수, 메서드 실행 정보 
  - Heap: 객체와 객체의 인스턴스 변수

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**
  - 기본형 데이터 타입: Stack 영역에 실제 값이 저장된다. 
  - 참조형 데이터 타입: 참조 변수는 Stack 에 저장되지만, 객체의 실제 데이터는 Heap 영역에 저장된다.

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**
  - `p` (참조 변수): Stack 영역에 저장된다.
  - `new Person() 객체`: Heap 영역에 저장된다.

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 스택 프레임은 메서드 호출과 함께 생성되고, 종료 시 자동으로 제거된다.
  - 반면 힙 영역의 객체는 다른 객체나 스레드에서 참조하고 있을 수 있기 때문에 Garbage Collector 가 필요 없다고 판단할 때까지 남아있다.

- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**
  - 공통점: 두 영역 모두 JVM 메모리의 일부이며 객체나 데이터를 저장한다.
  - 차이점
    - Static 영역: 클래스의 static 변수와 메서드가 저장되며, 클래스 로딩 시 생성된다.
    - Heap 영역: 객체와 인스턴스 변수가 저장되며, 런타임 시 동적 생성된다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
A. final 키워드는 변수, 메서드, 클래스에 사용할 수 있으며 선언된 대상의 변경을 금지한다.
컴파일러가 변수나 메서드를 변경할 수 없다는 것을 알고 코드를 더 효과적으로 최적화할 수 있다.
변경을 방지해 코드의 안정성과 최적화 가능성을 높이는 것이다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - final 키워드를 사용한다고 해서 큰 성능 차이가 발생하지는 않으나, 컴파일러 과정에서 최적화를 수행해 속도가 조금 더 빠르다.
  - 컴파일러는 변수를 호출하는 대신 실제 값을 직접 대입하는 방식으로 최적화 한다.

### 3. 변수는 어떤 것인가요?
A. 변수는 데이터를 저장하는 공간으로, 프로그램 실행 중 값이 변할 수 있다.
변수는 메모리의 특정 영역에 저장되며 변수 이름을 통해 해당 메모리 위치에 접근할 수 있다.

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**
  - 참조형 변수는 객체를 가리키는 주소값(참조값)만 저장한다.
  - 메모리 효율성: 객체는 크기가 클 수 있기 때문에 객체 전체를 저장하면 메모리를 많이 사용하므로 효율적으로 주소값만 저장한다.
  - 유연성: 참조값을 통해 객체의 위치를 추적하므로 객체를 동적으로 관리할 수 있다.

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**
  - 기본형 변수는 단순한 데이터(숫자, 문자 등)를 저장하기 때문에 메모리 크기가 작고 고정적이다.
  - 속도: 스택 영역에 저장하면 접근 속도가 빠르기 때문에 성능이 향상시킬 수 있다.
  - 관리 용이: 스택은 메서드 호출과 함께 생성 및 소멸되므로, 기본형 변수의 생명주기를 명확하고 효율적으로 관리할 수 있다.

- **변수와 상수의 차이는 무엇인가요?**
  - 변수: 값이 변경 가능하다. 실행 중에 다른 값으로 변경할 수 있다.
  - 상수: 값의 변경이 불가능하다.`final` 키워드를 통해 한 번 할당된 값을 수정할 수 없도록 한다.
  ```java
  // 변수
  int x = 5;
  x = 10; // 값 변경 가능
  
  // 상수
  final int x = 10;
  x = 20; // 컴파일 에러 발생
  ```

### 4. 부동소수점이 무엇인가요?
A. 부동 소수점이란 소수점을 고정하지 않고 유동적으로 움직이게 하여 실수를 표현하는 방식이다.
`float` 와 `double` 이 이에 해당한다.

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**
  - 부동 소수점은 정확한 값을 표현하지 못하고 근사값으로 저장하기 때문에, 소수점 계산 시 오차가 발생할 수 있다.
  - ex.
    ```java
    double a = 0.1;
    double b = 0.2;
    System.out(a + b); // 결과 = 0.30000000000000004
    ```

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**
  - 자바에서 정확한 실수 계산이 필요한 경우 `BigDecimal` 을 활용한다.
  - 부동소수점이 아닌 정확한 수의 표현을 지원하며, 소수점 오차 없이 정확한 계산이 가능하다.
  - ex.
    ```java
    BigDecimal a = new BigDecimal("0.1");
    BigDecimal a = new BigDecimal("0.2");
    BigDecimal sum = a.add(b);
    System.out(sum); // 결과 = 0.3
    ```

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**
  - BigDecimal 은 실수를 문자열 또는 정수 형태로 저장하고, 소수점 위치를 별도로 관리한다.
    - 내부적으로 `Scale` 을 사용해 소수를 저장한다.
    - ex.
      ```java
      BigDecimal num = new BigDecimal("123.45");
      // 정수 값: 12345
      // Scale: 2
      // 결과적으로 123.45는 (12345, 2)로 저장됨.
      ```

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?

- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**

- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**

- **`hashCode()` 의 용도는 무엇인가요?**

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**

- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**

- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**

- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.

### 9. 리플렉션에 대해 설명해 주세요.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

- **리플렉션을 언제 활용할 수 있을까요?**

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?

### 13. Error 와 Exception 의 차이가 무엇인가요?

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**

### 14. 자바에서 쓰레드를 생성하는 방법에는 어떤 것들이 있나요?

- **그렇다면 두 방법의 장단점은 무엇인가요?**

- **`Runnable` 인터페이스의 용도는 무엇인가요?**

- **왜 Thread 클래스의 `public static native Thread currentThread();` 는 static 으로 선언되어 있나요?**

- **쓰레드의 `start()` 과 `run()` 메서드는 어떤 차이가 있나요?**

- **아래 코드의 결과는 어떻게 될까요?**

  ```java
  class MyRunnable implements Runnable{
    public void run(){
      System.out.println("My Runnable is running");
      Thread currThread = Thread.currentThread();
      currThread.setName("thread in run method");
      System.out.println("Current thread in run : " + currThread.getName());
    }
  }

  class TestRunnable {
    public static void main(String[] args) {
      Thread thread = new Thread(new MyRunnable());
      thread.run();
      System.out.println("Current thread in main : " + Thread.currentThread().getName());
    }
  }
  ```

- **새로 생성된 쓰레드의 호출 스택은 언제 사라질까요?**

- **Callable 과 Runnable 의 차이는 무엇인가요? 왜 Callable 과 Future 인터페이스가 생겼나요?**

- **ExecutorService, Future 는 각각 무엇이며 어떤 용도로 쓰이나요?**

### 15. 쓰레드의 상태값에는 어떤 것들이 있나요?

- **`WAITING` 과 `BLOCKED` 의 차이는 무엇인가요?**

- **왜 `sleep()` 과 `yield()` 는 static 메서드인가요?**

- **`yield()` 과 `join()` 의 차이점은 무엇인가요?**

- **`sleep()` 과 `wait()` 의 차이점과 공통점은 무엇인가요?**

### 16. 쓰레드의 동기화는 무엇이며, 동기화에 사용되는 방법들은 어떤 것이 있나요?

- **`synchronized` 에 의한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`wait()`와 `notify()` 를 이용한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`java.util.concurrent.locks` 에 있는 Lock 과 Condition 은 위의 문제들을 어떻게 해결했나요?**

- **`volatile` 키워드는 어떻게 변수에 대한 읽기와 쓰기를 동기화하나요?**

### 17. `ConcurrentHashMap` 은 무엇이며 어떻게 thread-safe 를 보장하나요?

- **버킷이 비어있는 경우, 새로운 노드를 추가할 때는 어떻게 락을 걸지 않고 thread-safe 를 보장할 수 있나요?**

### 18. 함수형 프로그래밍은 무엇이며, 왜 필요한가요?

- **함수형 프로그래밍의 특징을 설명해주세요.**

- **자바에서는 어떻게 함수형 프로그래밍을 할 수 있나요?**

- **`@FunctionalInterface` 어노테이션의 역할은 무엇인가요?**

- **람다식과 함수형 인터페이스의 관계는 무엇인가요?**

- **람다표현식과 익명클래스의 차이는 무엇인가요?**

- **자바에서 미리 함수형 인터페이스를 정의해놓은 이유는 무엇인가요?**

### 19. 자바에서 I/O가 느린이유는 무엇인가요?

- **운영체제에서 I/O는 어떻게 동작하나요?**

- **자바 IO 패키지가 OS의 I/O 보다 훨씬 느린 이유는 무엇인가요?**

- **자바에서 NIO 패키지는 왜 IO 패키지에 비해 속도가 빠른가요?**

- **그러면 IO 가 무조건 나쁜 것일까요?**

### 20. 쓰레드풀, 커넥션풀 등 여러 Pool 이 있는데, 이들의 용도는 무엇일까요?

### 21. 쓰레드 로컬(Thread Local) 은 무엇인가요?

### 22. Stream 에서 Map,flatMap 과 Optional 에서 Map, flatMap의 차이는 무엇인가요?